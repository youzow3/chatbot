/*   This file is part of Chatbot.
 *
 *  Chatbot is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or any later version.
 *
 *  Chatbot is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 *  You should have received a copy of the GNU General Public License along
 * with Chatbot. If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * ChatbotLanguageModel:
 *
 * Interface that defines language model.
 *
 * All methods of this interface is considered as batch_size == 1 with variable
 * length tokens. Implementers are responsible for making stable text
 * generating function. At least, [method@LanguageModel.prefill] and
 * [method@LanguageModel.generate] should be implemented.
 */

#include "chatbot-language-model.h"

enum
{
  GENERATING,
  THINKING,
  N_SIGNALS
};

static int signals[N_SIGNALS];

G_DEFINE_INTERFACE (ChatbotLanguageModel, chatbot_language_model,
                    G_TYPE_OBJECT);

gchar *
chatbot_language_model_apply_chat_template_ (
    ChatbotLanguageModel *language_model, const GStrv role_and_message)
{
  GString *formatted;

  g_return_val_if_fail (CHATBOT_IS_LANGUAGE_MODEL (language_model), NULL);
  g_return_val_if_fail (role_and_message, NULL);

  formatted = g_string_new (NULL);
  for (gsize i = 0; i < g_strv_length (role_and_message); i++)
    {
      // Role
      if ((i % 2) == 0)
        g_string_append_printf (formatted, "%s: ", role_and_message[i]);
      // Message
      else
        g_string_append_printf (formatted, "%s\n\n", role_and_message[i]);
    }

  return g_string_free (formatted, FALSE);
}

static void
chatbot_language_model_default_init (ChatbotLanguageModelInterface *iface)
{
  iface->apply_chat_template = chatbot_language_model_apply_chat_template_;

  /**
   * ChatbotLanguageModel:parameter:
   *
   * Construction parameter of language models.
   */
  g_object_interface_install_property (
      iface,
      g_param_spec_string ("parameter", "parameter", "construction parameter",
                           NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));

  /**
   * ChatbotLanguageModel::generating:
   * @language_model: language model instance
   * @text: generated token
   *
   * Emits when a token is generated.
   *
   * Signal that emmited when a token is generated by methods. This means
   * [method@LanguageModel.generate] should emit this signal same count as how
   * many tokens are generated. Emitter should supply generated token's string.
   *
   * Returns: %TRUE if want to continue generating, %FALSE if want to stop
   * generating.
   */
  signals[GENERATING] = g_signal_new (
      "generating", CHATBOT_TYPE_LANGUAGE_MODEL, G_SIGNAL_RUN_LAST, 0, NULL,
      NULL, NULL, G_TYPE_BOOLEAN, 1, G_TYPE_STRING);

  /**
   * ChatbotLanguageModel::thinking:
   * @language_model: language model instance
   * @text: generated token
   *
   * Emits when a token is generated while model is thinking.
   *
   * Signal that emmited a token is generated while CoT (or similar way) by
   * methods. Emitter should supply generated token's string.
   *
   * Returns: %TRUE if want to continue thinking, %FALSE if want to stop
   * thinking and start generating.
   */
  signals[THINKING] = g_signal_new ("thinking", CHATBOT_TYPE_LANGUAGE_MODEL,
                                    G_SIGNAL_RUN_LAST, 0, NULL, NULL, NULL,
                                    G_TYPE_BOOLEAN, 1, G_TYPE_STRING);
}

/**
 * chatbot_language_model_new:
 * @type: GType of class that implement [iface@LanguageModel].
 * @parameter: Construction parameter for the @type.
 * @error: (out) (optional): Location to store error.
 *
 * Construct subclass of [iface@LanguageModel].
 *
 * Returns: (transfer full): Newly constructed instance.
 */
gpointer
chatbot_language_model_new (GType type, const gchar *parameter, GError **error)
{
  return g_initable_new (type, NULL, error, "parameter", parameter, NULL);
}

/**
 * chatbot_language_model_apply_chat_template:
 * @role_and_message: string array contains role and messages.
 *
 * Apply model specific chat template.
 *
 * Apply chat template for this specific model. role_and_message is consists of
 * (role, message) pair of strings, and thus, index 0, 1, 3, ... will be roles,
 * and 2, 4, 6, ... will be messages.
 *
 * Default implementation is:
 *
 * "[role]: [message]\n\n"
 *
 * Returns: Generated string with chat template applied.
 */
gchar *
chatbot_language_model_apply_chat_template (
    ChatbotLanguageModel *language_model, const GStrv role_and_message)
{
  ChatbotLanguageModelInterface *iface;

  g_return_val_if_fail (CHATBOT_IS_LANGUAGE_MODEL (language_model), NULL);
  g_return_val_if_fail (role_and_message, NULL);

  iface = CHATBOT_LANGUAGE_MODEL_GET_IFACE (language_model);
  g_return_val_if_fail (iface->apply_chat_template, NULL);
  return iface->apply_chat_template (language_model, role_and_message);
}

/**
 * chatbot_language_model_prefill:
 * @text: Text that the model will process.
 * @error: (out) (optional): Location to store error or %NULL.
 *
 * Perform prefill by given text.
 *
 * Returns: %TRUE if succeed, %FALSE on failure.
 */
gboolean
chatbot_language_model_prefill (ChatbotLanguageModel *language_model,
                                const gchar *text, GError **error)
{
  ChatbotLanguageModelInterface *iface;

  g_return_val_if_fail (CHATBOT_IS_LANGUAGE_MODEL (language_model), FALSE);
  g_return_val_if_fail (text, FALSE);
  g_return_val_if_fail ((error == NULL) || (*error == NULL), FALSE);

  iface = CHATBOT_LANGUAGE_MODEL_GET_IFACE (language_model);
  g_return_val_if_fail (iface->prefill, FALSE);
  return iface->prefill (language_model, text, error);
}

/**
 * chatbot_language_model_generate:
 * @error: (out) (optional): Location to store error or %NULL.
 *
 * Generating text until stop token or count is reached.
 *
 * Stop token and max generating count (or something else for stop condition)
 * are depended on implementers.
 *
 * Generating strategy is also depended on implementers. For example, use think
 * mode or not.
 *
 * Returns: (nullable) (type utf8) (transfer full): Generated entire string or
 * %NULL on failure.
 */
gchar *
chatbot_language_model_generate (ChatbotLanguageModel *language_model,
                                 GError **error)
{
  ChatbotLanguageModelInterface *iface;

  g_return_val_if_fail (CHATBOT_IS_LANGUAGE_MODEL (language_model), FALSE);
  g_return_val_if_fail ((error == NULL) || (*error == NULL), FALSE);

  iface = CHATBOT_LANGUAGE_MODEL_GET_IFACE (language_model);
  g_return_val_if_fail (iface->generate, FALSE);
  return iface->generate (language_model, error);
}

/**
 * chatbot_language_model_save_state:
 * @filename: File or directory path to save state.
 * @error: (out) (optional): Location to store error.
 *
 * Save state to specified file or directory.
 *
 * Returns: %TRUE if succeed, %FALSE on failure.
 */
gboolean
chatbot_language_model_save_state (ChatbotLanguageModel *language_model,
                                   const gchar *filename, GError **error)
{
  ChatbotLanguageModelInterface *iface;

  g_return_val_if_fail (CHATBOT_IS_LANGUAGE_MODEL (language_model), FALSE);
  g_return_val_if_fail (filename, FALSE);
  g_return_val_if_fail ((error == NULL) || (*error == NULL), FALSE);

  iface = CHATBOT_LANGUAGE_MODEL_GET_IFACE (language_model);
  if (iface->save_state == NULL)
    {
      // TODO check using G_IO_ERROR is OK or need to prepare own error
      // namespace.
      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
                   "Saving state is not supported for this module.");
      return FALSE;
    }

  return iface->save_state (language_model, filename, error);
}

/**
 * chatbot_language_model_load_state:
 * @filename: File or directory path to load state.
 * @error: (out) (optional): Location to store error.
 *
 * Load state from specified file.
 *
 * Returns: %TRUE if succeed, %FALSE on failure.
 */
gboolean
chatbot_language_model_load_state (ChatbotLanguageModel *language_model,
                                   const gchar *filename, GError **error)
{
  ChatbotLanguageModelInterface *iface;

  g_return_val_if_fail (CHATBOT_IS_LANGUAGE_MODEL (language_model), FALSE);
  g_return_val_if_fail (filename, FALSE);
  g_return_val_if_fail ((error == NULL) || (*error == NULL), FALSE);

  iface = CHATBOT_LANGUAGE_MODEL_GET_IFACE (language_model);
  if (iface->load_state == NULL)
    {
      // TODO check using G_IO_ERROR is OK or need to prepare own error
      // namespace.
      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
                   "Saving state is not supported for this module.");
      return FALSE;
    }

  return iface->load_state (language_model, filename, error);
}
